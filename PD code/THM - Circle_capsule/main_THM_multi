
import generate_coordinates as gc
import ADR
from multiprocessing import Pool
import time
import Multiprocess_task_function as mt
import bc_funcs as bc
import core_funcs as cf
import Physical_Field_Calculation as pfc
import plot_utils as plot
import numpy as np
from scipy.interpolate import griddata

rho_s, cs, ks = 1000.0, 2060.0, 1
rho_l, cl, kl = 1000.0, 4182.0, 0.6
Ts = 312.65
Tl = 313.65
L = 333
E = 25.7e9                  # Elastic modulus [Pa]
nu = 0.25                # Poisson's ratio
K = 1.0                  # Thermal conductivity [W/(m·K)]
alpha = 1.8e-5           # Thermal expansion coefficient [1/K]
h = 1.0
tolerance = 1e-14
Tsurr = 400
Tinit = 283.15
Tpre_avg = 283.15
""" Initialization of coarse regions and temperatures """
# dr1, dr2, dr3 are used to generate regional particle density by calling functions to create coordinates.
r = 20 * 1e-6  # Domain size in r and z directions (meters)

dr1 = 0.05 * 1e-6
dr2 = 0.05 * 1e-6
dr3 = 2 * dr2
dr_l = 0.4 * 1e-6

len1 = 0.5 * 1e-6
len2 = 0.5 * 1e-6
len3 = 1 * 1e-6

ghost_nodes_r = 3  # Number of ghost cells in the x (or r) direction
n_slices = 8
"""Note that n_slices here refers to the minimum number of layers. 
Subsequent checks and modifications will be performed 
in the gc.compute_layer_dr_r_nr function to ensure that the granularity of each layer is reasonable."""
num_processes = 1

total_time = 1000e-8
rms = 1e-12
# ------------------------
# Compute distance matrix and horizon mask
# ------------------------
if __name__ == "__main__":
    # Shared zoning
    start_time2 = time.time()
    """1. Definition of regional coordinates and area matrix (shared for T and M)"""

    zones, n_slices = gc.compute_layer_dr_r_nr(
        r, n_slices, dr1, dr2, dr3, dr_l, len1, len2, len3
    )

    for z in zones:
        print(f"Layer {z['layer']:2d}: dr = {z['dr']:.2e}, delta = {z['delta']:.2e}, "
              f"length = {z['length']:.2e}, Nr = {z['Nr']}")

    # ---------------- Temperature field ----------------
    phys_coords_list_t = []
    ghost_coords_list_t = []
    ghost_dict_list_t = []

    for i in range(n_slices):
        zone = zones[i]  # shared zone info
        dr_i = zone["dr"]
        Nr_i = zone["Nr"]

        coords_phys_t, ghost_coords_t, n_points_t, ghost_dict_t = gc.generate_one_slice_coordinates(
            r, Nr_i, ghost_nodes_r,
            zones,
            r_ghost_left=True,
            r_ghost_right=True,
            r_ghost_top=True,
            r_ghost_bot=True,
            n_slices=n_slices,
            slice_id=i,
            graph=True
        )
        print(f"[Temperature] Number of particles in region {i}: {n_points_t}")

        phys_labeled_t = np.hstack([coords_phys_t, np.full((coords_phys_t.shape[0], 1), i)])
        ghost_labeled_t = np.hstack([ghost_coords_t, np.full((ghost_coords_t.shape[0], 1), i)])
        phys_coords_list_t.append(phys_labeled_t)
        ghost_coords_list_t.append(ghost_labeled_t)
        ghost_dict_list_t.append(ghost_dict_t)

    # ---------------- Mechanical field ----------------
    phys_coords_list_m = []
    ghost_coords_list_m = []
    ghost_dict_list_m = []

    for i in range(n_slices):
        zone = zones[i]  # same shared zoning
        dr_i = zone["dr"]
        Nr_i = zone["Nr"]

        coords_phys_m, ghost_coords_m, n_points_m, ghost_dict_m = gc.generate_one_slice_coordinates(
            r, Nr_i, ghost_nodes_r,
            zones,
            r_ghost_left=True,
            r_ghost_right=False,
            r_ghost_top=True,
            r_ghost_bot=True,
            n_slices=n_slices,
            slice_id=i,
            graph=False
        )
        print(f"[Mechanical] Number of particles in region {i}: {n_points_m}")

        phys_labeled_m = np.hstack([coords_phys_m, np.full((coords_phys_m.shape[0], 1), i)])
        ghost_labeled_m = np.hstack([ghost_coords_m, np.full((ghost_coords_m.shape[0], 1), i)])
        phys_coords_list_m.append(phys_labeled_m)
        ghost_coords_list_m.append(ghost_labeled_m)
        ghost_dict_list_m.append(ghost_dict_m)

    # -------- Temperature field --------
    start_time_t = time.time()
    task_args_t = []
    for i in range(n_slices):
        coords_t = np.vstack([phys_coords_list_t[i], ghost_coords_list_t[i]])
        dr = zones[i]["dr"]  # shared
        delta = zones[i]["delta"]  # shared
        slice_id = zones[i]["layer"]  # shared
        task_args_t.append((coords_t, dr, delta, tolerance, slice_id))

    if num_processes == 1:
        results_t = [mt.compute_region_matrices(args) for args in task_args_t]
    else:
        with Pool(processes=num_processes) as pool:
            results_t = pool.map(mt.compute_region_matrices, task_args_t)

    distance_matrices_t = []
    partial_area_matrices_t = []
    horizon_masks_t = []
    true_indices_list_t = []

    for i, file_path in enumerate(results_t):
        data = np.load(file_path)
        distance_matrices_t.append(data["distance"])
        partial_area_matrices_t.append(data["area"])
        horizon_masks_t.append(data["mask"])
        true_indices_list_t.append(tuple(data["indices"]))

    end_time_t = time.time()
    print(f"[Temperature] Calculation of partial_area_matrices finished, elapsed real time = {end_time_t - start_time_t:.2f}s")

    # -------- Mechanical field --------

    c_m = []
    start_time_m = time.time()
    task_args_m = []
    for i in range(n_slices):
        coords_m = np.vstack([phys_coords_list_m[i], ghost_coords_list_m[i]])
        dr = zones[i]["dr"]  # shared
        delta = zones[i]["delta"]  # shared
        slice_id = zones[i]["layer"]  # shared
        c_i = (6.0 * E) / (np.pi * (delta ** 3) * h * (1.0 - 2.0 * nu) * (1.0 + nu))
        c_m.append(c_i)

        task_args_m.append((coords_m, dr, delta, tolerance, slice_id))

    if num_processes == 1:
        results_m = [mt.compute_region_matrices(args) for args in task_args_m]
    else:
        with Pool(processes=num_processes) as pool:
            results_m = pool.map(mt.compute_region_matrices, task_args_m)

    distance_matrices_m = []
    partial_area_matrices_m = []
    horizon_masks_m = []
    true_indices_list_m = []

    for i, file_path in enumerate(results_m):
        data = np.load(file_path)
        distance_matrices_m.append(data["distance"])
        partial_area_matrices_m.append(data["area"])
        horizon_masks_m.append(data["mask"])
        true_indices_list_m.append(tuple(data["indices"]))

    end_time_m = time.time()
    print(
        f"[Temperature] Calculation of partial_area_matrices finished, elapsed real time = {end_time_m - start_time_m:.2f}s")

    """2. Definition of particle information at the interface between regions """
    # Initialize structured dictionary
    # Temperature field boundary mapping
    ghost_top_t = {}
    ghost_bot_t = {}
    ghost_left_t = {}
    ghost_right_t = {}
    phys_t = {}

    for i in range(n_slices):
        ghost_top_t[i] = ghost_dict_list_t[i]["top"]
        ghost_bot_t[i] = ghost_dict_list_t[i]["bot"]
        ghost_left_t[i] = ghost_dict_list_t[i]["left"]
        ghost_right_t[i] = ghost_dict_list_t[i]["right"]
        phys_t[i] = phys_coords_list_t[i]

    # Save the matching relationship between each pair of adjacent regions
    boundary_neighbors_t = {}

    for i in range(n_slices):  # Region i is adjacent to region i+1 (vertical direction)
        # The lower boundary ghost point of region i corresponds to the physical point of region i+1
        if i <= n_slices - 2:
            dr_i = zones[i]["dr"]
            dr_ip1 = zones[i + 1]["dr"]
            ghost_coords_bot_t = ghost_bot_t[i][:, :2]
            phys_coords_ip1_t = phys_t[i + 1][:, :2]

            if abs(dr_i - dr_ip1) < tolerance:
                ghost_idx_bot_t, phys_idx_bot_t = bc.get_same_neighbor_points(
                    ghost_coords_bot_t, phys_coords_ip1_t, tol=tolerance)
            elif dr_i < dr_ip1:
                ghost_idx_bot_t, phys_idx_bot_t = bc.get_coarse_neighbor_points(
                    ghost_coords_bot_t, phys_coords_ip1_t, dr_fine=dr_i, tol=tolerance)
            else:  # dr_i > dr_ip1
                ghost_idx_bot_t, phys_idx_bot_t = bc.get_fine_neighbor_points(
                    ghost_coords_bot_t, phys_coords_ip1_t, dr_fine=dr_ip1, tol=tolerance)

            boundary_neighbors_t[(i, 'bot')] = {
                "ghost_indices": ghost_idx_bot_t,
                "phys_indices": phys_idx_bot_t,
                "target_region": i + 1
            }

            # Upper boundary of region i+1
            ghost_coords_top_t = ghost_top_t[i + 1][:, :2]
            phys_coords_i_t = phys_t[i][:, :2]
            if abs(dr_i - dr_ip1) < tolerance:
                ghost_idx_top_t, phys_idx_top_t = bc.get_same_neighbor_points(
                    ghost_coords_top_t, phys_coords_i_t, tol=tolerance)
            elif dr_ip1 < dr_i:
                ghost_idx_top_t, phys_idx_top_t = bc.get_coarse_neighbor_points(
                    ghost_coords_top_t, phys_coords_i_t, dr_fine=dr_ip1, tol=tolerance)
            else:
                ghost_idx_top_t, phys_idx_top_t = bc.get_fine_neighbor_points(
                    ghost_coords_top_t, phys_coords_i_t, dr_fine=dr_i, tol=tolerance)

            boundary_neighbors_t[(i + 1, 'top')] = {
                "ghost_indices": ghost_idx_top_t,
                "phys_indices": phys_idx_top_t,
                "target_region": i
            }

        coords_ghost_left_t = ghost_left_t[i][:, :2]
        coords_ghost_right_t = ghost_right_t[i][:, :2]
        coords_phys_t = phys_t[i][:, :2]
        dr = zones[i]["dr"]

        # Left boundary
        ghost_idx_left_t, phys_idx_left_t = bc.find_mirror_pairs(
            coords_ghost_left_t, coords_phys_t, tolerance
        )
        boundary_neighbors_t[(i, 'left')] = {
            "ghost_indices": ghost_idx_left_t,
            "phys_indices": phys_idx_left_t,
            "target_region": i
        }

        # Right boundary
        ghost_idx_right_t, phys_idx_right_t = bc.find_circle_mirror_pairs_multilayer(
            coords_ghost_right_t, coords_phys_t, dr, r
        )
        boundary_neighbors_t[(i, 'right')] = {
            "ghost_indices": ghost_idx_right_t,
            "phys_indices": phys_idx_right_t,
            "target_region": i
        }

    # Mechanical field boundary mapping
    ghost_top_m = {}
    ghost_bot_m = {}
    ghost_left_m = {}
    phys_m = {}

    for i in range(n_slices):
        ghost_top_m[i] = ghost_dict_list_m[i]["top"]
        ghost_bot_m[i] = ghost_dict_list_m[i]["bot"]
        ghost_left_m[i] = ghost_dict_list_m[i]["left"]
        phys_m[i] = phys_coords_list_m[i]

    # Save the matching relationship between each pair of adjacent regions
    boundary_neighbors_m = {}

    for i in range(n_slices):  # Region i is adjacent to region i+1 (vertical direction)
        # The lower boundary ghost point of region i corresponds to the physical point of region i+1
        if i <= n_slices - 2:
            dr_i = zones[i]["dr"]
            dr_ip1 = zones[i + 1]["dr"]
            ghost_coords_bot_m = ghost_bot_m[i][:, :2]
            phys_coords_ip1_m = phys_m[i + 1][:, :2]

            if abs(dr_i - dr_ip1) < tolerance:
                ghost_idx_bot_m, phys_idx_bot_m = bc.get_same_neighbor_points(
                    ghost_coords_bot_m, phys_coords_ip1_m, tol=tolerance)
            elif dr_i < dr_ip1:
                ghost_idx_bot_m, phys_idx_bot_m = bc.get_coarse_neighbor_points(
                    ghost_coords_bot_m, phys_coords_ip1_m, dr_fine=dr_i, tol=tolerance)
            else:  # dr_i > dr_ip1
                ghost_idx_bot_m, phys_idx_bot_m = bc.get_fine_neighbor_points(
                    ghost_coords_bot_m, phys_coords_ip1_m, dr_fine=dr_ip1, tol=tolerance)

            boundary_neighbors_m[(i, 'bot')] = {
                "ghost_indices": ghost_idx_bot_m,
                "phys_indices": phys_idx_bot_m,
                "target_region": i + 1
            }

            # Upper boundary of region i+1
            ghost_coords_top_m = ghost_top_m[i + 1][:, :2]
            phys_coords_i_m = phys_m[i][:, :2]
            if abs(dr_i - dr_ip1) < tolerance:
                ghost_idx_top_m, phys_idx_top_m = bc.get_same_neighbor_points(
                    ghost_coords_top_m, phys_coords_i_m, tol=tolerance)
            elif dr_ip1 < dr_i:
                ghost_idx_top_m, phys_idx_top_m = bc.get_coarse_neighbor_points(
                    ghost_coords_top_m, phys_coords_i_m, dr_fine=dr_ip1, tol=tolerance)
            else:
                ghost_idx_top_m, phys_idx_top_m = bc.get_fine_neighbor_points(
                    ghost_coords_top_m, phys_coords_i_m, dr_fine=dr_i, tol=tolerance)

            boundary_neighbors_m[(i + 1, 'top')] = {
                "ghost_indices": ghost_idx_top_m,
                "phys_indices": phys_idx_top_m,
                "target_region": i
            }

        coords_ghost_left_m = ghost_left_m[i][:, :2]
        coords_phys_m = phys_m[i][:, :2]

        # Left boundary (mirror about r=0)
        ghost_idx_left_m, phys_idx_left_m = bc.find_mirror_pairs(
            coords_ghost_left_m, coords_phys_m, tolerance
        )
        boundary_neighbors_m[(i, 'left')] = {
            "ghost_indices": ghost_idx_left_m,
            "phys_indices": phys_idx_left_m,
            "target_region": i
        }

    # Note: No right boundary for mechanical field

    """3. Definition of temperature field"""
    T_phys = {}
    T_left = {}
    T_right = {}
    T_top = {}
    T_bot = {}
    factor_mats = {}

    for i in range(n_slices):
        dr = zones[i]["dr"]
        coords_phys = phys_t[i][:, :2]
        coords_ghost_left = ghost_left_t[i][:, :2]
        coords_ghost_right = ghost_right_t[i][:, :2]
        coords_ghost_top = ghost_top_t[i][:, :2]
        coords_ghost_bot = ghost_bot_t[i][:, :2]
        distance_matrix = distance_matrices_t[i]

        # 1. Factor matrix
        threshold_distance = np.sqrt(2) * dr
        factor_mats[i] = np.where(distance_matrix <= threshold_distance + tolerance, 1.125, 1.0)

        # 2. Initialize the physical temperature field
        T_phys[i] = np.full(coords_phys.shape[0], Tinit)

        # 3. Initialize the ghost temperature field
        T_left[i] = np.full(coords_ghost_left.shape[0], Tinit)
        T_right[i] = np.full(coords_ghost_right.shape[0], Tsurr)
        T_top[i] = np.full(coords_ghost_top.shape[0], Tinit)
        T_bot[i] = np.full(coords_ghost_bot.shape[0], Tinit)

    # Boundary temperature assignment
    T = {}
    for (region_id, direction), neighbor_data in boundary_neighbors_t.items():
        ghost_indices = neighbor_data["ghost_indices"]
        phys_indices = neighbor_data["phys_indices"]
        target_region = neighbor_data["target_region"]

        dr1 = zones[region_id]["dr"]
        dr2 = zones[target_region]["dr"]

        if direction == "left":
            T_left[region_id][ghost_indices] = T_phys[region_id][phys_indices]

        elif direction == "top":
            if abs(dr1 - dr2) < tolerance:
                T_top[region_id] = bc.interpolate_temperature_for_same(
                    T_top[region_id], T_phys[target_region], ghost_indices, phys_indices
                )
            else:
                T_top[region_id] = bc.interpolate_temperature_for_coarse_and_fine(
                    T_top[region_id], T_phys[target_region], ghost_indices, phys_indices
                )
        elif direction == "bot":
            if abs(dr1 - dr2) < tolerance:
                T_bot[region_id] = bc.interpolate_temperature_for_same(
                    T_bot[region_id], T_phys[target_region], ghost_indices, phys_indices
                )
            else:
                T_bot[region_id] = bc.interpolate_temperature_for_coarse_and_fine(
                    T_bot[region_id], T_phys[target_region], ghost_indices, phys_indices
                )
    for (region_id, direction), neighbor_data in boundary_neighbors_t.items():
        if direction == 'right':
            T[region_id] = np.concatenate(
                [T_phys[region_id], T_left[region_id], T_right[region_id], T_top[region_id], T_bot[region_id]])
            ghost_indices = neighbor_data["ghost_indices"]
            phys_indices = neighbor_data["phys_indices"]
            T_right[region_id][ghost_indices] = 2 * Tsurr - T[region_id][phys_indices]


    """4. Definition of enthalpy for temperature field"""
    dt_th = cf.compute_dt_cr_th_solid_with_dist(
        rho_s,
        cs,
        ks,
        partial_area_matrices_t[0],  # region 1 partial_area_matrix
        horizon_masks_t[0],  # region 1 horizon_mask
        distance_matrices_t[0],  # region 1 distance_matrix
        zones[0]["delta"]  # region 1 elta
    ) * 0.5

    H = {}
    K = {}
    shape_factor_matrices = {}
    region_lengths_t = {}  # Used to store length information for each region
    segment_slices_t = {}

    for i in range(n_slices):
        # Get the current temperature array for each region
        T_p = T_phys[i]
        T_l = T_left.get(i, np.array([]))       # no suffix for T_left
        T_r = T_right.get(i, np.array([]))    # suffix for T_right
        T_t = T_top.get(i, np.array([]))      # suffix for T_top
        T_b = T_bot.get(i, np.array([]))      # suffix for T_bot

        # Segment length
        n_phys = len(T_p)
        n_left = len(T_l)
        n_right = len(T_r)
        n_top = len(T_t)
        n_bot = len(T_b)
        # build slices for [phys | left | right | top | bot]
        s0 = 0
        s1 = s0 + n_phys
        s2 = s1 + n_left
        s3 = s2 + n_right
        s4 = s3 + n_top
        s5 = s4 + n_bot
        segment_slices_t[i] = {
            "phys": slice(s0, s1),
            "left": slice(s1, s2),
            "right": slice(s2, s3),
            "top": slice(s3, s4),
            "bot": slice(s4, s5),
            "total_len": s5
        }

        # Total temperature field of the patchwork
        T[i] = np.concatenate([T_p, T_l, T_r, T_t, T_b])
        delta = zones[i]["delta"]

        # Save the length information for each segment
        region_lengths_t[i] = {
            'n_phys': n_phys,
            'n_left': n_left,
            'n_right': n_right,
            'n_top': n_top,
            'n_bot': n_bot
        }

        H[i] = cf.get_enthalpy(T[i], rho_l, cs, cl, L, Ts, Tl)
        shape_factor_matrices[i] = np.ones_like(horizon_masks_t[i], dtype=float)
        K[i] = cf.build_K_matrix(
            T[i],
            cf.compute_thermal_conductivity_matrix,
            factor_mats[i],
            partial_area_matrices_t[i],
            shape_factor_matrices[i],
            distance_matrices_t[i],
            horizon_masks_t[i],
            true_indices_list_t[i],
            ks, kl, Ts, Tl, delta, dt_th
        )

    """4. Definition of Mechanical field"""
    # Mechanical field initialization
    # ---------- 1) Initialize displacement/velocity/acceleration ----------
    Ur, Uz = {}, {}
    Vr, Vz = {}, {}
    Ar, Az = {}, {}
    region_lengths_m = {}  # Used to store length information for each region
    segment_slices_m = {}  # per-region slices into concatenated order: [phys | left | top | bot]
    CorrList_T = {}
    T_m = {}
    dir_r_m, dir_z_m = {}, {}  # The direction matrix can still be represented by _m to denote “the direction matrix of the mechanical field.”
    coords_all_m_list = [np.vstack([phys_coords_list_m[i], ghost_coords_list_m[i]]) for i in range(n_slices)]
    coords_all_t_list = [np.vstack([phys_coords_list_t[i], ghost_coords_list_t[i]]) for i in range(n_slices)]

    for i in range(n_slices):
        coords_all_m = np.vstack([phys_coords_list_m[i], ghost_coords_list_m[i]])
        coords_all_t = np.vstack([phys_coords_list_t[i], ghost_coords_list_t[i]])
        CorrList_T[i] = pfc.shrink_Tth_by_matching_coords(coords_all_m_list[i], coords_all_t_list[i])

        n_phys = phys_coords_list_m[i].shape[0]
        n_left = ghost_left_m[i].shape[0]
        n_top = ghost_top_m[i].shape[0]
        n_bot = ghost_bot_m[i].shape[0]

        region_lengths_m[i] = {
            'n_phys': n_phys,
            'n_left': n_left,
            'n_top': n_top,
            'n_bot': n_bot
        }
        s0 = 0
        s1 = s0 + n_phys
        s2 = s1 + n_left
        s3 = s2 + n_top
        s4 = s3 + n_bot
        segment_slices_m[i] = {
            'phys': slice(s0, s1),
            'left': slice(s1, s2),
            'top': slice(s2, s3),
            'bot': slice(s3, s4),
            'total_len': s4
        }
        total_points_region = (
                phys_coords_list_m[i].shape[0]
                + ghost_top_m[i].shape[0]
                + ghost_bot_m[i].shape[0]
                + ghost_left_m[i].shape[0]  # Mechanical field without right boundary
        )

        total_len = segment_slices_m[i]['total_len']  # = n_phys + n_left + n_top + n_bot
        Ur[i] = np.zeros(total_points_region)  # radial disp
        Uz[i] = np.zeros(total_points_region)  # axial disp
        Vr[i] = np.zeros(total_points_region)  # radial vel
        Vz[i] = np.zeros(total_points_region)  # axial vel
        Ar[i] = np.zeros(total_points_region)  # radial acc
        Az[i] = np.zeros(total_points_region)  # axial acc

        dir_r_m[i], dir_z_m[i] = pfc.compute_direction_matrix(
            coords_all_m_list[i],
            Ur[i],
            Uz[i],
            horizon_masks_m[i]
        )


    """     5. Displacement initialization      """
    task_args_accel_m = []
    for i in range(n_slices):

        task_args_accel_m.append((
            coords_all_m_list[i],  # coords_all
            Ur[i], Uz[i],  # Ur_curr, Uz_curr
            horizon_masks_m[i],  # horizon_mask
            dir_r_m[i], dir_z_m[i],  # dir_r, dir_z
            c_m[i],  
            partial_area_matrices_m[i],  # partial_area_matrix
            rho_s,  # rho
            T[i], Tpre_avg,  # T_curr, T_prev  
            nu, alpha, CorrList_T[i] # nu, alpha
        ))

    # ---------- 3) Calculation (serial/multiprocessing) ----------
    if num_processes == 1:
        results_accel = [mt.compute_accelerated_velocity(args) for args in task_args_accel_m]
    else:
        with Pool(processes=num_processes) as pool:
            results_accel = pool.map(mt.compute_accelerated_velocity, task_args_accel_m)

    # Fill in the acceleration for each area
    for idx, (Ar_new, Az_new) in enumerate(results_accel):
        Ar[idx] = Ar_new
        Az[idx] = Az_new

    # ---------- 4) Calculate Fr_0 / Fz_0, λ, and half-step velocity based on acceleration ----------
    Fr_0, Fz_0 = {}, {}
    Fr = {}
    Fz = {}
    cr_n = {}
    cz_n = {}
    lambda_diag_matrix = {}
    Vr_half, Vz_half = {}, {}

    for i in range(n_slices):

        Fr_0[i] = Ar[i] * rho_s
        Fz_0[i] = Az[i] * rho_s

        # λ Diagonal (ADR)
        lambda_diag_matrix[i] = ADR.compute_lambda_diag_matrix(
            partial_area_matrices_m[i],  # (N, N)
            distance_matrices_m[i],  # (N, N)
            c_m[i],
            horizon_masks_m[i]  # (N, N)
        )
        # Half-step speed
        Vr_half[i] = (1 / 2) * (Fr_0[i] / lambda_diag_matrix[i])
        Vz_half[i] = (1 / 2) * (Fz_0[i] / lambda_diag_matrix[i])

    # ------------ 3) Calculation (serial / multi-process)------------
    if num_processes == 1:
        results_accel = [mt.compute_accelerated_velocity(args) for args in task_args_accel_m]
    else:
        with Pool(processes=num_processes) as pool:
            results_accel = pool.map(mt.compute_accelerated_velocity, task_args_accel_m)

    # ------------ 4) Backfill results ------------
    for idx, (Ar_new, Az_new) in enumerate(results_accel):
        Ar[idx] = Ar_new
        Az[idx] = Az_new

    # ------------------------
    # Time-stepping loop
    # ------------------------
    nsteps_th = int(total_time / dt_th)
    print_interval = int(10 / dt_th)  # Print progress every 10 simulated seconds
    print(f"Total steps: {nsteps_th}")
    print(f"thermal steps: {dt_th}")
    start_time = time.time()
    nsteps_m = int(1000)

    for step1 in range(nsteps_th):
        print(f"✅ Completed {step1 + 1}/{nsteps_th} steps of calculation")
        task_args = []
        for i in range(n_slices):
            delta = zones[i]["delta"]
            lengths = region_lengths_t[i]
            args = (
                i,
                T[i],
                H[i],
                K[i],
                factor_mats[i],
                partial_area_matrices_t[i],
                shape_factor_matrices[i],
                distance_matrices_t[i],
                horizon_masks_t[i],
                true_indices_list_t[i],
                delta,
                dt_th,
                rho_s, cs, cl, L, Ts, Tl, ks, kl
            )
            task_args.append(args)

        if num_processes == 1:
            # Serial execution
            results = [mt.update_temperature_for_region(args) for args in task_args]
        else:
            # Parallel execution
            with Pool(processes=num_processes) as pool:
                results = pool.map(mt.update_temperature_for_region, task_args)

        # ✅ Split results
        for region_id, Tnew, Hnew, Knew in results:

            sl = segment_slices_t[region_id]
            T_phys[region_id] = Tnew[sl["phys"]]
            T_left[region_id] = Tnew[sl["left"]]
            T_right[region_id] = Tnew[sl["right"]]
            T_top[region_id] = Tnew[sl["top"]]
            T_bot[region_id] = Tnew[sl["bot"]]
            H[region_id] = Hnew
            K[region_id] = Knew

        # ✅ Unified handling of boundary conditions
        for (region_id, direction), neighbor_data in boundary_neighbors_t.items():
            ghost_indices = neighbor_data["ghost_indices"]
            phys_indices = neighbor_data["phys_indices"]
            target_region = neighbor_data["target_region"]

            dr1 = zones[region_id]["dr"]
            dr2 = zones[target_region]["dr"]

            if direction == "left":
                T_left[region_id][ghost_indices] = T_phys[region_id][phys_indices]

            elif direction == "top":
                if abs(dr1 - dr2) < tolerance:
                    T_top[region_id] = bc.interpolate_temperature_for_same(
                        T_top[region_id], T_phys[target_region], ghost_indices, phys_indices
                    )
                else:
                    T_top[region_id] = bc.interpolate_temperature_for_coarse_and_fine(
                        T_top[region_id], T_phys[target_region], ghost_indices, phys_indices
                    )
            elif direction == "bot":
                if abs(dr1 - dr2) < tolerance:
                    T_bot[region_id] = bc.interpolate_temperature_for_same(
                        T_bot[region_id], T_phys[target_region], ghost_indices, phys_indices
                    )
                else:
                    T_bot[region_id] = bc.interpolate_temperature_for_coarse_and_fine(
                        T_bot[region_id], T_phys[target_region], ghost_indices, phys_indices
                    )
        for (region_id, direction), neighbor_data in boundary_neighbors_t.items():
            if direction == 'right':
                T[region_id] = np.concatenate(
                    [T_phys[region_id], T_left[region_id], T_right[region_id], T_top[region_id], T_bot[region_id]])
                ghost_indices = neighbor_data["ghost_indices"]
                phys_indices = neighbor_data["phys_indices"]
                T_right[region_id][ghost_indices] = 2 * Tsurr - T[region_id][phys_indices]

        # ✅ Reassemble after updating the boundaries.

        for step in range(nsteps_m):
            Ur_all_prev = np.concatenate([Ur[j] for j in range(n_slices)])
            Uz_all_prev = np.concatenate([Uz[j] for j in range(n_slices)])

            for i in range(n_slices):
                T[i] = np.concatenate([T_phys[i], T_left[i], T_right[i], T_top[i], T_bot[i]])
                Ar_i, Az_i = mt.compute_accelerated_velocity((
                    coords_all_m_list[i],  # coords_all
                    Ur[i], Uz[i],  # Ur_curr, Uz_curr
                    horizon_masks_m[i],  # horizon_mask
                    dir_r_m[i], dir_z_m[i],  # dir_r, dir_z
                    c_m[i],  # c
                    partial_area_matrices_m[i],  # partial_area_matrix
                    rho_s,  # rho
                    T[i], Tpre_avg,  # T_curr, T_prev
                    nu, alpha, CorrList_T[i]  # nu, alpha, CorrList_T
                ))
                Ar[i], Az[i] = Ar_i, Az_i
                Fr[i] = Ar[i] * rho_s
                Fz[i] = Az[i] * rho_s

                cr_n[i] = ADR.compute_local_damping_coefficient(
                    Fr[i], Fr_0[i], Vr_half[i], lambda_diag_matrix[i], Ur[i], 1
                )
                cz_n[i] = ADR.compute_local_damping_coefficient(
                    Fz[i], Fz_0[i], Vz_half[i], lambda_diag_matrix[i], Uz[i], 1
                )
                Fr_0[i] = Fr[i]
                Fz_0[i] = Fz[i]

                Vr_half[i], Ur[i] = ADR.adr_update_velocity_displacement(
                    Ur[i], Vr_half[i], Fr[i], cr_n[i], lambda_diag_matrix[i], 1
                )
                Vz_half[i], Uz[i] = ADR.adr_update_velocity_displacement(
                    Uz[i], Vz_half[i], Fz[i], cz_n[i], lambda_diag_matrix[i], 1
                )

                for (region_id, direction), neighbor_data in boundary_neighbors_m.items():
                    if direction not in ('top', 'bot'):
                        continue
                    ghost_indices = neighbor_data["ghost_indices"]  # Index relative to ghost segment (local)
                    phys_indices = neighbor_data["phys_indices"]  # Index relative to target's phys segment (local)
                    target_region = neighbor_data["target_region"]

                    dr1 = zones[region_id]["dr"]
                    dr2 = zones[target_region]["dr"]

                    # Extract the ghost segment slice from this area and the phys segment slice from the target area.
                    sl_ghost = segment_slices_m[region_id][direction]  # 'top' or 'bot'
                    sl_phys = segment_slices_m[target_region]['phys']

                    # Retrieve the corresponding view segment
                    # (note: this is a 1D segment vector, ghost_indices/phys_indices are the local indices of this segment)
                    Ur_ghost_seg = Ur[region_id][sl_ghost]
                    Uz_ghost_seg = Uz[region_id][sl_ghost]
                    Ur_phys_seg = Ur[target_region][sl_phys]
                    Uz_phys_seg = Uz[target_region][sl_phys]

                    # Same/different grid interpolation: General functions for reusing temperature fields
                    # (they apply to any scalar field)
                    if abs(dr1 - dr2) < tolerance:
                        Ur_new_seg = bc.interpolate_temperature_for_same(
                            Ur_ghost_seg, Ur_phys_seg, ghost_indices, phys_indices
                        )
                        Uz_new_seg = bc.interpolate_temperature_for_same(
                            Uz_ghost_seg, Uz_phys_seg, ghost_indices, phys_indices
                        )
                    else:
                        Ur_new_seg = bc.interpolate_temperature_for_coarse_and_fine(
                            Ur_ghost_seg, Ur_phys_seg, ghost_indices, phys_indices
                        )
                        Uz_new_seg = bc.interpolate_temperature_for_coarse_and_fine(
                            Uz_ghost_seg, Uz_phys_seg, ghost_indices, phys_indices
                        )

                    # Write back to this area ghost segment
                    Ur[region_id][sl_ghost] = Ur_new_seg
                    Uz[region_id][sl_ghost] = Uz_new_seg
                    # Mechanical field left boundary displacement set to zero
                    Ur[i][segment_slices_m[i]["left"]] = 0

            Ur_all_curr = np.concatenate([Ur[j] for j in range(n_slices)])
            Uz_all_curr = np.concatenate([Uz[j] for j in range(n_slices)])
            # Convergence judgment
            delta_Ur_all = Ur_all_curr - Ur_all_prev
            delta_Uz_all = Uz_all_curr - Uz_all_prev
            rms_increment = np.sqrt(np.mean(delta_Ur_all ** 2 + delta_Uz_all ** 2))

            if rms_increment < rms:
                print(f"[Mechanical]Converged at step {step} with RMS {rms_increment:.3e}")
                break
            if step > 0 and step % 10 == 0:
                print(f"[Mechanical] step {step}")

    U_phys = {
        i: {
            "Ur": Ur[i][segment_slices_m[i]['phys']],
            "Uz": Uz[i][segment_slices_m[i]['phys']],
            "Umag": np.sqrt(
                Ur[i][segment_slices_m[i]['phys']] ** 2 +
                Uz[i][segment_slices_m[i]['phys']] ** 2
            )
        }
        for i in range(n_slices)
    }
    plot.plot_temperature_contour_in_circle(phys_coords_list_t, dr1, T_phys, radius=r)
    plot.plot_displacement_contours_in_circle(
        phys_coords_list_m,U_phys,r,  
        titles=('Ur (m)', 'Uz (m)', '|U| (m)'),
        levels=20
    )
    end_time2 = time.time()
    print(f"Whole Calculation time = {end_time2 - start_time2:.2f}s")
