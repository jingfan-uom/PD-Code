import numpy as np
import matplotlib.pyplot as plt

# ==============================
# Material properties (Based on Case 5.2 in the paper)
# ==============================
Kl = 0.2  # Thermal conductivity in liquid state (W/m-K)
Ks = 0.2  # Thermal conductivity in solid state (W/m-K)
Cs = 2000  # Specific heat capacity in solid state (J/kg-K)
Cl = 2000  # Specific heat capacity in liquid state (J/kg-K)
rho = 780  # PCM density (kg/m^3)
L = 168000  # PCM latent heat (J/kg)

# Phase change temperature range (46.5 - 48.5°C)
T_low = 46.5  # Solid phase temperature (°C)
T_high = 48.5  # Liquid phase temperature (°C)
T_left = 65.0  # Left boundary temperature (°C)
T_right = 25.0  # Right boundary temperature (°C)

# ==============================
# Spatial and time parameters
# ==============================
L_dom = 0.14  # Computational domain length (m)
N_particles = 112  # 56 particles used in the paper
dx = L_dom / N_particles  # Note: No longer using N_particles - 1
dt = 1  # Time step size (s)
delta = 4.5 * dx  # Horizon radius

ghost_nodes = 3  # Boundary ghost nodes

# Center the physical grid points within each cell
x_phys = np.linspace(0.06 + dx / 2, 0.20 - dx / 2, N_particles)

x_ghost_left = np.arange(0.06 - (ghost_nodes) * dx + dx / 2, 0.06, dx)  # Left ghost nodes
x_ghost_right = np.arange(0.20 + dx / 2, 0.20 + dx / 2 + (ghost_nodes - 1) * dx, dx)  # Right ghost nodes

x = np.concatenate([x_ghost_left, x_phys, x_ghost_right])

# ==============================
# Initialize temperature field
# ==============================
T = np.full_like(x, 25.0)  # Initial temperature set to 25°C

# Step 2: Compute distance matrix
distance_matrix = np.abs(x[:, None] - x[None, :])

# Step 3: Horizon mask for valid interactions (Boolean matrix)
horizon_mask = distance_matrix <= delta

# Step 4: Axisymmetric correction factor matrix
axisymmetric_factor = 2 * x[None, :] / (x[:, None] + x[None, :])

print("Distance matrix:\n", distance_matrix)
print("\nHorizon mask:\n", horizon_mask)
print("\nAxisymmetric factor:\n", axisymmetric_factor)
print("\nx-coordinate matrix:\n", x)

# ==============================
# Compute initial enthalpy H
# ==============================
def enthalpy(T):
    """ Compute enthalpy H (based on phase transition region handling) """
    H = np.copy(T)
    for i in range(len(T)):
        if T[i] < T_low:
            H[i] = Cs * T[i]
        elif T[i] > T_high:
            H[i] = Cs * T_low + L + Cl * (T[i] - T_high)
        else:
            H[i] = Cs * T_low + (L / (T_high - T_low)) * (T[i] - T_low)
    return H

H = enthalpy(T)

# ==============================
# Convert enthalpy H to temperature T
# ==============================
def temperature(H):
    """ Convert enthalpy to temperature """
    T_new = np.copy(H)
    for i in range(len(H)):
        if H[i] <= Cs * T_low:
            T_new[i] = H[i] / Cs
        elif H[i] >= Cs * T_low + L:
            T_new[i] = (H[i] - (Cs * T_low + L)) / Cl + T_high
        else:
            T_new[i] = ((H[i] - Cs * T_low) * (T_high - T_low) / L) + T_low
    return T_new

# ==============================
# Compute thermal conductivity K(T)
# ==============================
def thermal_conductivity(T):
    """ Compute thermal conductivity based on temperature """
    return Ks if T < T_low else Kl

# ==============================
# Apply Dirichlet boundary conditions using ghost cells
# ==============================
def apply_dirichlet_bc_mirror(T, ghost_nodes):
    """
    Apply Dirichlet boundary conditions using the mirror method (Ghost Cell approach).
    T_left and T_right represent the fixed boundary temperatures.
    """
    for i in range(ghost_nodes):
        interior_index = 2 * ghost_nodes - i - 1
        T[i] = 2.0 * T_left - T[interior_index]

    n = len(T)
    for i in range(n - ghost_nodes, n):
        dist = i - (n - ghost_nodes)
        interior_index = (n - ghost_nodes - 1) - dist
        T[i] = 2.0 * T_right - T[interior_index]

    return T

# Initialize temperature with boundary conditions
T = apply_dirichlet_bc_mirror(T, ghost_nodes)

# ==============================
# Build thermal conductivity matrix
# ==============================
def build_K_matrix(T_array, ghost_nodes):
    N = len(T_array)
    K_values = np.array([thermal_conductivity(T) for T in T_array])
    K_avg_matrix = (K_values[:, None] + K_values[None, :]) / 2 / delta

    K_matrix = np.zeros((N, N))
    valid = (distance_matrix != 0) & horizon_mask
    numerator = K_avg_matrix * axisymmetric_factor * dt / rho
    denominator = (distance_matrix ** 2) / dx
    K_matrix[valid] = numerator[valid] / denominator[valid]

    for i in range(ghost_nodes, N - ghost_nodes):
        K_matrix[i, i - 1] *= 1.5
        K_matrix[i, i + 1] *= 1.5
    return K_matrix

# ==============================
# Update temperature and enthalpy
# ==============================
def update_temperature(T, H):
    """ Update temperature field """
    new_T = np.copy(T)
    new_H = np.copy(H)
    new_K = build_K_matrix(new_T, ghost_nodes)

    delta_T_matrix = new_T[None, :] - new_T[:, None]
    adj_matrix = new_K * delta_T_matrix

    # Sum along rows to compute net heat flux for each node
    flux = np.sum(adj_matrix, axis=1)
    new_H = new_H + flux

    new_T = temperature(new_H)
    new_T = apply_dirichlet_bc_mirror(new_T, ghost_nodes)

    return new_T, new_H

import time
start_time = time.time()  # Record start time

# ==============================
# Time-stepping loop
# ==============================
time_steps = int(21601 / dt)

time_points = {
    3600: None,
    10800: None,
    21600: None
}

for step in range(time_steps):
    T, H = update_temperature(T, H)
    current_time = step * dt

    if int(current_time) in time_points:
        time_points[int(current_time)] = np.copy(T)

    if step % 3601 == 0:
        print(f"t = {current_time / 3600:.2f} h, Temperature (first 10 points):", T[:10])

# ==============================
# Extract temperatures
# ==============================
T_1h = time_points[3600]
T_3h = time_points[10800]
T_6h = time_points[21600]

# ==============================
# Plot temperature profiles
# ==============================
plt.plot(x_phys, T_1h[ghost_nodes: -ghost_nodes], label="1 Hour")
plt.plot(x_phys, T_3h[ghost_nodes: -ghost_nodes], label="3 Hours")
plt.plot(x_phys, T_6h[ghost_nodes: -ghost_nodes], label="6 Hours")

plt.xlabel('Position (m)')
plt.ylabel('Temperature (°C)')
plt.title('Temperature Profile at 1h, 3h, 6h')
plt.legend()
plt.grid(True)
plt.show()

end_time = time.time()  # Record end time
elapsed = end_time - start_time  # Compute elapsed time
print(f"Computation completed in {elapsed:.2f} seconds")

